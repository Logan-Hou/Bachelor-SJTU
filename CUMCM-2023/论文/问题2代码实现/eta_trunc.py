import numpy as npimport pandas as pdfrom sun_vector import sun_vectorimport class_mirror as c_mimport itertoolsimport mathimport timefrom class_mirror import mirroralpha = [0,2.325*10**(-4),4.65*10**(-3)]beta = [0, 0.4*np.pi, 0.8*np.pi, 1.2*np.pi, 1.6*np.pi]def normalize_vector(vector):    return vector/np.linalg.norm(vector)def cut_off(reflect_vec, chosen_x, alpha, beta):    # reflect_vec = mirror.reflect_vec    e_l = c_m.normalize_vector(np.array([0,reflect_vec[2], -reflect_vec[1]]))    e_h = c_m.normalize_vector(np.array([-reflect_vec[2]**2-reflect_vec[1]**2, reflect_vec[0]*reflect_vec[1], reflect_vec[0]*reflect_vec[2]]))    t_cut = reflect_vec + np.tan(alpha)*(np.cos(beta)*e_l + np.sin(beta)*e_h)    a = t_cut[0]**2 + t_cut[1]**2    b = 2*np.dot(t_cut[0:2],chosen_x[0:2])    c = chosen_x[0]**2+chosen_x[1]**2-12.25    sol = quadratic_solver(a,b,c)    if sol == 'Error':        return 0    elif len(sol) == 1: #只有一个交点 相切        if 76 <= chosen_x[2] + sol[0]*t_cut[2] <= 84:            return 1        else:            return 0    else:        t = np.min(np.abs(sol))        if 76 <= chosen_x[2] + t*t_cut[2] <= 84 :            return 1        else:            return 0def quadratic_solver(a,b,c):    delta = b**2-4*a*c    if delta < 0:        return 'Error'    elif delta == 0:        return [-b/(2*a)]    else:        return [(-b + np.sqrt(delta))/(2*a), (-b - np.sqrt(delta))/(2*a)]def eta_trunc_1point(reflect_vec,vec_xij,alpha_list,beta_list): # todo huge workload!!!!!    count_series = pd.Series() # monte_carlo    for alpha, beta in itertools.product(alpha_list,beta_list):        count_series.loc[f'({alpha},{beta})'] = cut_off(reflect_vec, vec_xij, alpha, beta)    eta_trunc_1point = sum(count_series)/len(count_series)    return eta_trunc_1point